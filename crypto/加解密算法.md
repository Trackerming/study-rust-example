### 基础概念

#### 数学原理

##### NP问题和P问题

- 离散对数困难问题
- 大数因子分解问题

##### 费马小定理

- a与素数p互素，则恒有 a^(p-1) mod p = 1
- 比如3与7互素，3^6 mod 7 = 3^2*3^2*3^2 mod 7 = 2*2*2 mod 7 = 1

##### 欧拉函数

- 与n互素的个数记作 ф(n)，ф(1) = 1，对于质数n ф(n) = n-1
- 费马定理可变为：a^(ф(n)) = 1 mod n
- 两个不相等的质数p和q n = p*q,ф(n) = ф(p)*ф(q) = (p-1)*(q-1)
- 素数幂p^r, ф(p^r) = ф(p^(r-1)*p) = p^(r-1)(p-1)
- 欧拉定理：对于任意互素的a和n
    - a^(ф(n)) = 1 mod n

#### 对称加密

##### DES

> 数据加密标准，主要过程的重点在轮函数的处理和轮子密钥的生成

- 子密钥的生成过程
    - 64bit的key，实际有效位为56bit
- 轮函数的处理
    - 初始明文的置换 64bit，然后分为L和R
    - 对R
        - E扩展：32 bit -> 48 bit （R1）
        - 与密钥异或：R1 & Key_i （R2）
        - S盒子：48 bit -> 32 bit （R3）
            - b1和b6代表行，b2到b4代表列
            - 获取到的数字用二进制表示
        - P盒变换：(R4)
        - L与计算得到的R4异或得到这一轮的R
    - 上一轮的R变为L，然后输入去计算R

###### 3DES

##### AES

#### 非对称加密

##### RSA

- 生成密钥对：

    - 随机选择两个大素数p和q。
    - 计算n = p * q。
    - 计算欧拉函数φ(n) = (p - 1) * (q - 1)。
    - 选择一个整数e，满足1 < e < φ(n)，且e与φ(n)互质。
    - 所以；e^φ(φ(n)) mod φ(n) = 1，则e^(φ(φ(n))-1)*e mod φ(n) = 1,所以模反元素必存在
    - 计算模反元素d，使得 (d * e) % φ(n) = 1。
    - 公钥为(n, e)，私钥为(n, d)。
- 加密：

    - 将明文转换为整数m，满足 0 <= m < n。
    - 计算密文c = (m^e) % n。

- 解密：

    - 使用私钥中的d，计算明文m = (c^d) % n。

- 举例如下
    - 选择大素数 5和3
    - n = p*q = 15
    - 欧拉函数φ(n) = (p-1)*(q-1) = 2*4 = 8（1，2，4，7，8，11, 13, 14）
    - 选择 1<e<8,与8互质，e = 3，不知道p和q的话φ(n)难算
    - 计算模反元素d，e^(4-1) mod 8 = 3^3 mod 8 = 1*3 mod 8 = 3 mod 8 = 3
    - 所以私钥为(n,d)即（15， 3），公钥也为（n，e）（15，3）

    - 加解密，假设消息m为2
        - 公钥加密 c = m^e mod n = 2^3 mod 15 = 8
        - 私钥解密 c^d mod n = 8^3 mod 15 = 4*8 mod 15 = 2
        - 公式推导 c = m^e mod n；解密 c^d mod n = m^(e*d) mod n = m^(k*φ(n)+1) mod n = m^(kφ(n))*m mod n = 1*m = m
    - 签名验签
        - 私钥签名 s = m^d mod n = 2^3 mod 15 = 8
        - 持有公钥方验签名 s^e mod n = m ^(d*e) mod n = m

> 欧拉函数在RSA加密算法中起到了至关重要的作用。在RSA算法中，欧拉函数通常用来计算公钥和私钥的参数。具体来说，欧拉函数的作用包括：
> 计算公钥参数：欧拉函数φ(n)用于选择公钥e，确保e与φ(n)互质。这样选择的公钥e能够确保加密过程的安全性。
> 计算私钥参数：欧拉函数φ(n)也用于计算私钥d，使得(d * e) % φ(n) = 1。私钥d的选择需要满足这个条件，以确保解密过程的正确性。
> 因此，欧拉函数在RSA加密算法中扮演了关键的角色，帮助确定了加密和解密过程中所需的参数，保证了RSA算法的安全性和有效性

##### ECC

> 椭圆曲线的公式

```
$y^2 = x^3 + a*x + b$
```

- 有限域
- 阶
- G
- 逆元
- a和b

###### 加解密

> 公钥可以用来加密数据，拥有对应私钥的能解密出原始的消息M

- 公钥加密
    - m：消息
    - d：私钥，公钥Q = d*G
    - k: 随机数

    ```
    C1 = m+k*Q
    C2 = k*G
    ```

> 上述过程求解k是一个困难问题，下述过程由于知道d，所以可以结合C2得到k*Q，消除这部分就可以解密出来数据

- 私钥解密
    - 解密过程如下

      ```
      C1 = m+k*Q = m+k*d*G = m+d*k*G
         = m+d*C2
      ```

###### 签名验签

- 私钥签名
    - m：消息
    - d：私钥，公钥Q = d*G
    - k: 随机数
    - r: k*G的x（横坐标）
    - H: m的hash值

    ```
    R = k*G = (x, y)
    s = k^-1 * (H+d*r) mod n
    ```

- 公钥验签
    - 验证方收到m，K，和s， R

    ```
    s^(-1) * H *G + s^(-1) * r * Q = kG
    ```

    - 推导过程如下

    ```
    s^(-1) * H*G + s^(-1) *r*Q = s^(-1) *(H*G + r*d*G)
     = k/(H + d*r) *(H*G + r*d*G)
     = (k*H*G + k*r*d*G)/(H + d*r)
     = (k*G(H + r*d))/(H + d*r)
     = k*G
    ```

- 如果对相同的私钥采用相同的k进行了签名可知
    - m1 m2：两个不同的消息的hash
    - d：私钥
    - k：随机数
    - r: k*G的x

        ```
        s1 = k^(-1) *(m1+dr) mod n s2 = k^(-1)*(m2+d*r) mod n
        s1 - s2 = k^(-1)*(m1+dr-m2-dr)
        k=(m1-m2)/(s1-s2)
        d = (s1*k -m1)/r
        ```
  > 上述公式过程可知：相同的k可以借助签名和消息的hash推导出来，得到了随机数k，密钥也就清楚了；这里有https:
  //capturetheether.com/challenges/accounts/account-takeover/ 示例

- 恢复公钥
    - r的逆元r^-1
    - -h*r^(-1) 和 s*r^(-1)
    - s*r^(-1)*R-(h*r^(-1))G
    - 计算如下
      ```js
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
         throw new Error('recovery id 2 or 3 invalid');
      const prefix = (rec & 1) === 0 ? '02' : '03';
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      ```
      ```
      s*r^(-1)*R-(h*r^(-1))G = r^(-1)*(sR -hG)
        = r^(-1)*(k^(-1)*(h+dr)R -hG)
        = r^(-1)*(h*k*G/k + dr*kG/k -hG)
        = r^(-1)*(drG)
        = drG/r = dG mod n = Q
      ```
- 公式中几个重要的点
    1. 知道r即k*G的横坐标，算不出随机数k
    2. 知道s可以很容易算出s的逆元，随机数k也是
    3. 验证的过程中也没有暴露过私钥，私钥信息被包含进公钥里然后被消元了
    4. 公式里有一个对称性，d*r是签名中的一个元素，也是验证需要去消除的_

##### schnorr签名

- （素数群下）生成密钥
    - 已知群内的一个合法元素x，当作私钥
    - 公钥则为 y = g^x，g是生成元，这里还是离散对数困难问题
- 签名
    - 消息M
    - 选择随机数 k，也属于群内元素
    - 计算 r = g^k
    - 计算e =Hash(r||M),对r和M串联后进行hash
    - s = k-x*e，则生成了签名对(s, e)
- 验证签名
    - 计算 r_v = g^sy^e,得到e_v = H(r_v||M) 是否等于 e
    - 分析如下
        - r_v = g^s*y^e = g^(k-x*e)*(g^x)^(e) = g^(k-xe+xe) = g^k = r
        - 所以使用r_v得到的hash e_v应该等于e

- ecc下的schnorr签名
    - 生成密钥
        - 已知合法元素x，作为私钥
        - 公钥为 Y = x*G, 还是离散对数困难问题
    - 签名
        - 消息M，
        - 随机数k，也属于群内元素
        - 计算R = k*G
        - 计算e = H(R||M)
        - 计算s = k+e*x mod n
        - 签名则为(R, s)
    - 验签
        - 计算s*G = k*G+e*x*G=R+e*Y 是否相等

    - 应用在多签门限下
        - s1 = k1+e*x1 s2 = k2+e*x2
        - s1+s2 = k1+k2+e(x1+x2)
        - 验证签名的时候 (s1+s2)*G = (k1+k2)*G+e(Y1+Y2)
        - 所以多方只需要协商(k1+k2+..k_n)的和，并且e用随机数的和计算就是一个固定值？

##### eddsa

- 椭圆曲线生成元G，阶为n
- 生成密钥
    - 合法的群内元素d，计算sha512(d) = lower256bit+higher256bit
    - 令y = lower256bit，则公钥为Y = y*G
- 签名
    - 消息M
    - 随机数k = sha256(higher256bit, M)
    - 计算承诺R = k*G
    - 计算调整e = sha256(R, Y, M)
    - 计算响应s = k+e*y mod n
    - 签名为（R, s）
- 验签
    - 计算e_v = sha256(R, Y, M)
    - s*G = k*G+ e*y*G = R+e_v*Y，判断是否相等
    - 应用在门限签名下则同schnorr签名类似

> 由上述可知，相比于schnorr签名的话，随机数的生成比较确定，而且基本不会重复，不会出现相同的R造成密钥泄漏的问题

- 相同的r对不同的交易进行签名的风险如下
- s1 = k+e1*x s2 = k+e2*x
    - 所以，s1-s2 = e1*x-e2*x
    - x = (s1-s2)/(e1-e2)
